\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{subsubsection}

\setlength{\textheight}{22cm}
\setlength{\textwidth}{15cm}
\setlength{\leftmargin}{-0.5 in}
\setlength{\topmargin}{0.35in}
\setlength{\topmargin}{0.1in}
\setlength{\evensidemargin}{0. in}
\setlength{\oddsidemargin}{0. in}

\parindent 5 pt
\parskip 5 pt


    \setcounter{secnumdepth}{5} 
\setcounter{tocdepth}{5}

    \begin{document}
\def\bx{{\bf x}}
\def\bv{{\bf v}}
\def\ba{{\bf a}}
\def\badot{{\bf \dot{a}}}
\def\batwodot{{\bf a}^{(2)}}
\def\bathreedot{{\bf a}^{(3)}}
\def\bj{{\bf j}}
\def\dt{{\Delta t}}
\def\comment#1{}
\def\sub#1{_{\rm #1}}
\def\sup#1{^{\rm #1}}
\def\APJ{{\it Ap. J. }}
\def\APJL{{\it Ap. J. Lett. }}


\title{Data format for visualization/analysis of collisional $N$-body simulation
{\large 
Ver 0.0 --- Aug 4 2011
}
}
\author{Kob2011 collaboration}
\maketitle

\tableofcontents

\newpage

\thispagestyle{empty}




\section{Introduction}

\begin{itemize}

  \item need for common data format
  \item need to be able to reproduce complete trajectory of particles
    of interests
  \item machine independence
  \item performance
  \item parallel processing
\end{itemize}

\section{Changes}
\subsection{Aug 17, 2011}

Data format for binary components (or any hierarchical object)
defined.


\section{Basic idea}

We need to store the data sufficient to reconstruct the orbits of
individual particles. Conseptually, what we need is a stream of
phase-space information of particles, such as:
\begin{verbatim}
  particle_id, time, mass, x, y, z, vx, vy, vz, ...
  particle_id, time, mass, x, y, z, vx, vy, vz, ...
  particle_id, time, mass, x, y, z, vx, vy, vz, ...
\end{verbatim}
However, the data format must be flexible enough to be able to include
more information such as
\begin{itemize}
  \item radius, and other info related to stellar evolution
  \item merger history
  \item whatever else you can think of
\end{itemize}

One way to construct such a flexible data format is to use
self-describing data format, such as XML or YAML. For simplicity,
we adopt YAML here.

\subsection{Some basics of YAML}

The following is a simple example of YAML data which can be directly
converted to/from an Ruby object:

\begin{verbatim}
--- !!Particle
id: 0
x:
  - 0.1
  - 0.2
  - 0.3
v:
  - -1
  - -2
  - -3
m: 1.0
\end{verbatim}

If this text is in a file ``test.yaml'', one can read in it by

\begin{verbatim}
class Particle
  def taguri
    return 'x-private:Particle'
  end
end
require 'yaml'
YAML.add_private_type('Particle') do |type, val|
  YAML.object_maker(Particle, val)
end
obj= YAML.load_file('test.yaml')
\end{verbatim}

The content of the object is now:
\begin{verbatim}
p obj
-> #<Particle:0xb7d151c0 @v=[-1, -2, -3], @id=0,
       @x=[0.1, 0.2, 0.3], @m=1.0>
\end{verbatim}

As one can see, in this way we created an object of class Particle,
with index, position, velocity, and mass given in the text. In the
above example, the line

\begin{verbatim}
--- !!Particle
\end{verbatim}
indicates that the following text should generate a ruby object with
name ``Particle''.

\begin{verbatim}
id: 0
\end{verbatim}
defines a member variable with name ``id'', and value 0 for this
particular instance
\begin{verbatim}
x:
  - 0.1
  - 0.2
  - 0.3
\end{verbatim}
means the member valiable ``x'' is an array with three elements. The
first ``-'' means this line is a data for an array.
By default, numbers without ``.'' are regarded as integers, and with
``.'' floating point. Note that indentation has meaning here and ``-''
must be indented the same level or deeper than ``x'' and should be aligned.
I guess I do not need to explain ``v'' and ``m''

\section{Particle Stream Data Format}


\subsection{normal particles}

With the  minimal description of YAML in the previous section, now
we can define the generic data format (not yet for binaries, though):
The data format is the stream of YAML reporesentation of particle
object, like

\begin{verbatim}
--- !!Particle
id: 0
t: 0
x:
  - 0.1
  - 0.2
  - 0.3
v:
  - -1
  - -2
  - -3
m: 1.0
--- !!Particle
id: 1
t: 0
x:
  - 0.2
  - 0.3
  - 0.4
v:
  - 0
  - 0
  - 0
m: 1.0
....
\end{verbatim}
We need to have some naming convension, so that defferent programs can
understand at least the basic common part of data. So we have

\begin{center}
\begin{tabular}{|c|l|}
\hline
name & description\\
\hline
id & index (can be arbitrary text)\\
parent\_id & index  of parent\\
m & mass\\
t & time\\
dt & timestep\\
x  & position, array with three elements\\
v  & velocity, array with three elements\\
p  & potential\\
a  & acceleration, array with three elements\\
j  & jerk, array with three elements\\
s  & snap, array with three elements\\
c  & crackle, array with three elements\\
pop  & pop, array with three elements\\
X\_something & User-defined extension\\
\hline
\end{tabular}
\end{center}

We call this format with basic naming convension PSDF (Particle Stream
Data Format). Here, ``X-something'' implies that one can use any name
starting with ``X-'' to record whatever thing one likes. If different
users use the same name, like ``X\_predicted\_position'' for different
things, that might cause confusion. So it might be better to have your
own tag, like ``NBODY6'' or ``Starlab'' as the second-level tag, so
that you have ``X\_Starlab\_predicted\_position''.

We call a YAML document which corresponds to a single particle object
as ``worldpoint'', since it is a point on the worldline associated
with a particle. It is translated to an object of Particle class, to
call it particle is a bit confusing.

\subsection{hierarchical subsystems}

In many dynamics code, it is necessary to apply some special treatment
for binary stars or other compact subsystems, and it is desirable to
be able to  retain such data structure in the I/O format. We express
such data structure by ``upward'' pointers. A binary, with ``name''
``0+1'', composed of two particles ``0'' and ``1'' appears in the data
file just as a normal particle:


\begin{verbatim}
--- !!Particle
id: 0+1
t: 0
x:
  - 0.1
  - 0.2
  - 0.3
v:
  - -1
  - -2
  - -3
m: 2.0
\end{verbatim}

It looks just as a normal particle. If one wants to say more, it is
possible to include some more info, using user-defined extension
(X\_something).

Components need to have the index of their parent, and we assume that
the coordinates of components (and time derivatives) are relative to
that of their parent.

So the worldpoint data of two components look like:

\begin{verbatim}
--- !!Particle
id: 0
parent\_id: 0+1
t: 0
x:
  - 0.1
  - 0.0
  - 0.0
v:
  - -1
  - 0
  - 0
m: 1.0
\end{verbatim}

and

\begin{verbatim}
--- !!Particle
id: 1
parent\_id: 0+1
t: 0
x:
  - -0.1
  - 0.0
  - 0.0
v:
  - 1
  - 0
  - 0
m: 1.0
\end{verbatim}


Note that there is no need to explicitly express formation and
distruction of the  ``0+1'' particle. It can just appear in the file
when it is constructed, and from then on particles 0 and 1 will have
``parent\_id'' in the output data and that means their coordinates are
relative. When the composite particle disappear, the parent\_id tag
just disappear from the output fields of particles 0 and 1.


\section{Some remarks}

\subsection{File format}
PSDS does not define the on-memory data description. It does not
define how the individual YAML documents are stored.

There are variety of ways to store worldpoints in file(s). In one
extreme, all worldpoints are stored in a single file, in the order
defined by time sequence. In the opposite extreme, one woldpoint is
stored in one file. We could think of anything in between, such as
single file for one particle or single file for some period in time.

In order to do some parallel I/O, using multiple files may be more
natural. We do not yet specify any particular form of parallel access,
though. 

\section{To do}

\begin{itemize}
\item Add more examples
\end{itemize}  


\appendix

\section{Repository}


\begin{verbatim}
   git@github.com:jmakino/Particle-Stream-Data-Format.git
\end{verbatim}

you can download it by:
\begin{verbatim}
  mkdir foo
  cd foo
  git clone git://github.com/jmakino/Particle-Stream-Data-Format.git
\end{verbatim}

To update:

\begin{verbatim}
  git pull
\end{verbatim}
  
\section{Sample codes}
Also in the github.

\subsection{Base library}
psdf.rb:
\begin{verbatim}
require 'yaml'
class Particle
  def taguri
    return 'x-private:Particle'
  end
end
YAML.add_private_type('Particle') do |type, val|
  YAML.object_maker(Particle, val)
end
\end{verbatim}

This is current minimal ``library'', which defines particle class and
``Particle'' tag.

\subsection{Simple program to generate a psdf file}

writetest.rb:
\begin{verbatim}
require "psdf.rb"
class Particle
  attr_accessor :id, :x   
  def initialize
    @id=0
    @t=0
    @x=[0,1,2]
  end
end
(0..10).each{|id|
  obj=Particle.new
  obj.id =id;
  obj.x[0]=id*0.1
  print YAML.dump(obj)
}
\end{verbatim}

This one generate 10 worldpoints.

\subsection{Simple program to read a psdf file}

readtest.rb:
\begin{verbatim}
require "psdf.rb"
a = []
while s = gets("--- ")
  print s
  print "\n\nend of one gets\n\n"
  print s, "\n"
  obj = YAML.load(s) 
  a.push obj if obj
end
p a
\end{verbatim}

This one reads in 10 particles and store everything in a single array.

\subsection{An ACS Body method to write a psdf worldpoint}

acs\_psdf.rb:
\begin{verbatim}
require "psdf.rb"
class Particle
  attr_accessor :id, :x, :v, :a, :p, :j, :m, :t, :dt
end

class Body
  def to_psdf
    obj=Particle.new
    obj.id = @body_id
    obj.t  = @time
    obj.x = Array[*@pos]
    obj.v = Array[*@vel]
    obj.a = Array[*@acc]
    obj.j = Array[*@jerk]
    obj
  end
  def psdf_output
    print YAML.dump(self.to_psdf)
  end
end
\end{verbatim}

In the ACS Body class, position, velocity and other vector data are of
class {\tt Vector}, not {\tt Array}. So you need to convert them to
{\tt Array}.

\subsection{An OpenGL animation program}

The file testplot.rb gives a simple example. It it intended to be a
skelton code, with minimal UI and other stuff. It takes an input file
with name ``testin'', in which a sequence of psdf world points is
stored (can come from shared-timestep or individual-timestep code).

This program requires ruby-opengl library. To install this (if not
already installed) try:
\begin{verbatim}
  sudo gem install opengl
\end{verbatim}
On my machine with CentOS 5.5, it failed with:
\begin{verbatim}
sudo gem install ruby-opengl
Building native extensions.  This could take a while...
ERROR:  Error installing ruby-opengl:
        ERROR: Failed to build gem native extension.

/usr/bin/ruby -rubygems /usr/lib/ruby/gems/1.8/gems/rake-0.8.7/bin/rake RUBYARCHDIR=/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/lib RUBYLIBDIR=/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/lib
/usr/bin/ruby mkrf_conf.rb
(in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1)
rake
gcc  -fPIC -g -O2    -Wall -DRUBY_VERSION=187  -I/usr/include -I/usr/lib/ruby/1.8/x86_64-linux -I/usr/lib/ruby/site_ruby/1.8 -I. -c gl-enums.c
(in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/ext/gl)
gl-enums.c:6  include :
../common/common.h:45:21: error: GL/glut.h: 
                                              rake aborted!
Command failed with status (1): [gcc  -fPIC -g -O2    -Wall -DRUBY_VERSION=...]
/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/ext/gl/Rakefile:29
(See full trace by running task with --trace)
rake aborted!
Command failed with status (1): [rake...]

(See full trace by running task with --trace)


Gem files will remain installed in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1 for inspection.
Results logged to /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/gem_make.out
\end{verbatim}

In this case, you need to install GLUT library, by
\begin{verbatim}
  sudo yum install freeglut   freeglut-devel
\end{verbatim}

    \end{document}
