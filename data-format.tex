\documentclass[12pt]{article}
\usepackage{graphicx}
\usepackage{subsubsection}

\setlength{\textheight}{22cm}
\setlength{\textwidth}{15cm}
\setlength{\leftmargin}{-0.5 in}
\setlength{\topmargin}{0.35in}
\setlength{\topmargin}{0.1in}
\setlength{\evensidemargin}{0. in}
\setlength{\oddsidemargin}{0. in}

\parindent 5 pt
\parskip 5 pt


    \setcounter{secnumdepth}{5} 
\setcounter{tocdepth}{5}

    \begin{document}
\def\bx{{\bf x}}
\def\bv{{\bf v}}
\def\ba{{\bf a}}
\def\badot{{\bf \dot{a}}}
\def\batwodot{{\bf a}^{(2)}}
\def\bathreedot{{\bf a}^{(3)}}
\def\bj{{\bf j}}
\def\dt{{\Delta t}}
\def\comment#1{}
\def\sub#1{_{\rm #1}}
\def\sup#1{^{\rm #1}}
\def\APJ{{\it Ap. J. }}
\def\APJL{{\it Ap. J. Lett. }}


\title{Data format for visualization/analysis of collisional $N$-body simulation\\
{\large 
Ver 0.0 --- Aug 4 2011\\
Ver 0.1 --- Aug 17 2011\\
}
}
\author{Kob2011 collaboration}
\maketitle

\tableofcontents

\newpage

\thispagestyle{empty}




\section{Introduction}

\begin{itemize}

 \item need for common data format
 \item need to be able to reproduce complete trajectory of particles
   of interests
 \item machine independence
 \item performance
 \item parallel processing
\end{itemize}

\section{Basic idea}


We need to store the data sufficient to reconstruct the orbits of
individual particles. Conceptually, what we need is a stream of
phase-space information of particles, such as:
\begin{verbatim}
 particle_id, time, mass, x, y, z, vx, vy, vz, ...
 particle_id, time, mass, x, y, z, vx, vy, vz, ...
 particle_id, time, mass, x, y, z, vx, vy, vz, ...
\end{verbatim}
However, the data format must be flexible enough to be able to include
more information such as
\begin{itemize}
 \item radius, and other info related to stellar evolution
 \item merger history
 \item whatever else one can think of
\end{itemize}

One way to construct such a flexible data format is to use
self-describing data format, such as XML or YAML. For simplicity,
we adopt YAML here.

\subsection{Some basics of YAML}

The following is a simple example of a data in YAML format.


\begin{verbatim}
--- !!Particle
id: 0
r:
 - 0.1
 - 0.2
 - 0.3
v:
 - -1
 - -2
 - -3
m: 1.0
\end{verbatim}

In the above example, the line

\begin{verbatim}
--- !!Particle
\end{verbatim}
Is the header, which indicates that it describes the data of an object
of type {\tt Particle}.


\begin{verbatim}
id: 0
\end{verbatim}
defines a field with name ``id'', and value 0.
\begin{verbatim}
r:
 - 0.1
 - 0.2
 - 0.3
\end{verbatim}
means the field ``r'' is an array with three elements. The
first ``-'' means this line is a data for an array.
By default, numbers without ``.'' are regarded as integers, and with
``.'' floating point. Note that indentation has meaning here and ``-''
must be indented the same level or deeper than ``r'' and should be aligned.
Here,  ``v'' and ``m'' are similar.


\section{Particle Stream Data Format}


With the  minimal description of YAML in the previous section, now
we can define the generic data format (not yet for binaries, though):
The data format is the stream of YAML representation of particle
object, like

\begin{verbatim}
--- !!Particle
id: 0
t: 0
r:
 - 0.1
 - 0.2
 - 0.3
v:
 - -1
 - -2
 - -3
m: 1.0
--- !!Particle
id: 1
t: 0
r:
 - 0.2
 - 0.3
 - 0.4
v:
 - 0
 - 0
 - 0
m: 1.0
....
\end{verbatim}

\subsection{Formalities}

For a data format to be understandable by a computer program, there
need to be some convension. We start with the list of reserved words
for the names:

\begin{center}
\begin{tabular}{|c|l|}
\hline
name & description\\
\hline
id & index (can be arbitrary text)\\
m & mass\\
t & time\\
t\_max & max time to which this record is valid \\
r  & position, array with three elements\\
v  & velocity, array with three elements\\
pot  & potential\\
acc  & acceleration, array with three elements\\
jerk  & jerk, array with three elements\\
snap  & snap, array with three elements\\
crackle  & crackle, array with three elements\\
pop  & pop, array with three elements\\
\hline
\end{tabular}
\end{center}

We require that time, position, velocity and higher derivatives are
consistent (that if position is given in parsec and time in year,
velocity must be in parsec/year, not km/s, for example). Also, we
expect the users of this format to follow the convension of using
these names to descrive these physical quantities. Here, {\tt t\_max}
is rather special, in that it gives the maximum possible time that
this record is used to predict the orbit of this particle.

Any of these fields are not required. One can make a record without
velocity, mass, time or whatsoever. If a program needs the positions
of particles but the data file does not give them, the program should
raise error message. We will give example APIs in several languages in
the appendix.

In the a data file, if the record of one particle is not produced
after certain time, the analysis/visualization program regard that it
somehow vanished after time {\tt t\_max}.

We considered the possibility of defining a special record for
creation and destruction of a particle, but decided against that to
keep the parser as simple as possible to write.

We call this format with basic naming convention PSDF (Particle Stream
Data Format). If one wants to add his/her own data, one possibility is
to use a name like ``NBODY6\_predicted\_position''. We do not enforce
the use of keyword  ``X\_'', but are not against it.

We call a YAML document which corresponds to a single particle object
as ``worldpoint'', since it is a point on the worldline associated
with a particle. 


\section{Some remarks}

\subsection{File format}
PSDF does not define the on-memory data description. It does not
define how the individual YAML documents are stored.

There are variety of ways to store worldpoints in file(s). In one
extreme, all worldpoints are stored in a single big file, in the order
defined by the time sequence. In the opposite extreme, one worldpoint is
stored in one file. We could think of anything in between, such as
single file for one particle or single file for some period in time.

In order to do some parallel I/O, using multiple files may be more
natural. We do not yet specify any particular form of parallel access,
though. We might provide some examples, though.


\section{Repository}


\begin{verbatim}
  git@github.com:jmakino/Particle-Stream-Data-Format.git
\end{verbatim}

you can download it by:
\begin{verbatim}
 mkdir foo
 cd foo
 git clone git://github.com/jmakino/Particle-Stream-Data-Format.git
\end{verbatim}

To update:

\begin{verbatim}
 git pull
\end{verbatim}

\section{Sample codes}
Also in the github.

\subsection{Base library}
psdf.rb:
\begin{verbatim}
require 'yaml'
class Particle
 def taguri
   return 'x-private:Particle'
 end
end
YAML.add_private_type('Particle') do |type, val|
 YAML.object_maker(Particle, val)
end
\end{verbatim}

This is current minimal ``library'', which defines particle class and
``Particle'' tag.

\subsection{Simple program to generate a psdf file}

writetest.rb:
\begin{verbatim}
require "psdf.rb"
class Particle
 attr_accessor :id, :r   
 def initialize
   @id=0
   @t=0
   @r=[0,1,2]
 end
end
(0..10).each{|id|
 obj=Particle.new
 obj.id =id;
 obj.x[0]=id*0.1
 print YAML.dump(obj)
}
\end{verbatim}

This one generate 10 worldpoints.

\subsection{Simple program to read a psdf file}

readtest.rb:
\begin{verbatim}
require "psdf.rb"
a = []
while s = gets("--- ")
 print s
 print "\n\nend of one gets\n\n"
 print s, "\n"
 obj = YAML.load(s) 
 a.push obj if obj
end
p a
\end{verbatim}

This one reads in 10 particles and store everything in a single array.

\subsection{An ACS Body method to write a psdf worldpoint}

acs\_psdf.rb:
\begin{verbatim}
require "psdf.rb"
class Particle
 attr_accessor :id, :r, :v, :a, :p, :j, :m, :t, :dt
end

class Body
 def to_psdf
   obj=Particle.new
   obj.id = @body_id
   obj.t  = @time
   obj.r = Array[*@pos]
   obj.v = Array[*@vel]
   obj.a = Array[*@acc]
   obj.j = Array[*@jerk]
   obj
 end
 def psdf_output
   print YAML.dump(self.to_psdf)
 end
end
\end{verbatim}

In the ACS Body class, position, velocity and other vector data are of
class {\tt Vector}, not {\tt Array}. So you need to convert them to
{\tt Array}.

\subsection{An OpenGL animation program}

The file testplot.rb gives a simple example. It it intended to be a
skeleton code, with minimal UI and other stuff. It takes an input file
with name ``testin'', in which a sequence of psdf world points is
stored (can come from shared-timestep or individual-timestep code).

This program requires ruby-opengl library. To install this (if not
already installed) try:
\begin{verbatim}
  sudo gem install opengl
\end{verbatim}
On my machine with CentOS 5.5, it failed with:
\begin{verbatim}
sudo gem install ruby-opengl
Building native extensions.  This could take a while...
ERROR:  Error installing ruby-opengl:
        ERROR: Failed to build gem native extension.

/usr/bin/ruby -rubygems /usr/lib/ruby/gems/1.8/gems/rake-0.8.7/bin/rake RUBYARCHDIR=/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/lib RUBYLIBDIR=/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/lib
/usr/bin/ruby mkrf_conf.rb
(in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1)
rake
gcc  -fPIC -g -O2    -Wall -DRUBY_VERSION=187  -I/usr/include -I/usr/lib/ruby/1.8/x86_64-linux -I/usr/lib/ruby/site_ruby/1.8 -I. -c gl-enums.c
(in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/ext/gl)
gl-enums.c:6  include :
../common/common.h:45:21: error: GL/glut.h: 
                                              rake aborted!
Command failed with status (1): [gcc  -fPIC -g -O2    -Wall -DRUBY_VERSION=...]
/usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/ext/gl/Rakefile:29
(See full trace by running task with --trace)
rake aborted!
Command failed with status (1): [rake...]

(See full trace by running task with --trace)


Gem files will remain installed in /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1 for inspection.
Results logged to /usr/lib/ruby/gems/1.8/gems/ruby-opengl-0.60.1/gem_make.out
\end{verbatim}

In this case, you need to install GLUT library, by
\begin{verbatim}
  sudo yum install freeglut   freeglut-devel
\end{verbatim}

    \end{document}
